#!/bin/bash

get_choice()
{
echo ""
echo "Please select an action:"
echo ""
echo "   1) Install RO JFFS2 rootfs on flash with /etc and /var RW on tmpfs"
echo "   2) Install RW JFFS2 rootfs on flash with no special setup"
echo "   3) Install root filesystem on harddisk"
echo "   4) Install RO CRAMFS rootfs on flash"
echo "   5) Install RO SQUASHFS rootfs on flash  (recommended for RO fs)"
echo "   6) Install RO YAFFS2 rootfs on NAND flash"
echo "   7) Install RW YAFFS2 rootfs on NAND flash (Recommended for RW fs for Large Page only)"
echo "   8) Exit"
echo ""
echo -n "Selection: "
}


stty sane
stty erase '^H' echoe echok -echoprt -iexten -ixany
PATH=".:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin"
TERM=linux

DOCSIS=

# Empty for LE, _be for BE
ENDIAN=

if [ $# -ge 1 ]; then
    Arg1="$1"
    TFTP_SERVER=`echo "$Arg1" | cut -f 1 -d ':'`
    CUR_REL=`echo "$Arg1" | sed -n '/\:/p' | cut -f 2 -d ':'`
else
    TFTP_SERVER=stb-irva-01
    CUR_REL=@VERSION@
fi

if [ -z "$CUR_REL" ]; then
    IMGPFX=""
else
    IMGPFX="$CUR_REL/"
fi

# JFFS2 only works when the endian of the flash is the same as that of the CPU.
# For the 93730 STBs with a BE flash, we can only use JFFS for now
case  `uname -m` in
#7038)
#JFFS=jffs
#IMAGE="jffs-`uname -m`.img"
#;;
356*|7*|97*)
FSTYPE=jffs2
IMAGE="jffs2-`uname -m`${DOCSIS}${ENDIAN}.img"
;;
93730)
FSTYPE=jffs
IMAGE="jffs-`uname -m`${DOCSIS}${ENDIAN}.img"
;;
esac


echo ""
echo "stbutil v3.92 - Settop configuration utility"
echo "               Copyright (C) 2001,02,03,04 Broadcom Corporation"
echo "               original codes shill@broadcom.com"
echo "               v3.0 tht patched for 2418SR3"
echo "               tht rewritten for 2418sr4,sr5 to support BB"
echo "               v3.5 sr6: tht added support for HD on BB"
echo "               v3.6 on 2.4.25-0: tht added support for Cramfs"
echo "               v3.7 on 2.4.25-0.2: tht Read HD geometry and switch on uname"
echo "               v3.8 on 2.4.25-1.1: tht Integrate with BusyBox 1.0"
echo "               v3.9 on 2.6.12-2.1: jipeng handle input args and tftp error"
echo "               v3.92 on 2.6.18-2.0: tht: Added YAFFS2 install"
echo "               v3.92 on 2.6.18-2.0: tht: Added SQUASHFS install"
echo ""
echo "Usage: stbutil [tftpserver:[subdir]]"
echo "  Please specify an argument to stbutil to override the default."
echo "  Options 1 and 2 will retrieve the $FSTYPE (or cramfs) flash image" $IMAGE "from"
if [ ! -z "$CUR_REL" ]; then
    echo "  $TFTP_SERVER:$CUR_REL/"
else
    echo "  $TFTP_SERVER:/tftpboot"
fi


RESPONSE=0
while :
do
   get_choice

   read RESPONSE
   if [ -z "$RESPONSE" ]; then
	echo "Please enter a value between 1 and 8"
	continue
   fi
   case "$RESPONSE" in
   1|2|3|4|5|6|7|8|9|0)
   	;;
   *)
      echo "Only single digits are accepted"
      continue
      ;;
   esac
   if  [ $RESPONSE -lt 1 -o $RESPONSE -gt 8 ]; then
        echo "Invalid choice"
	continue
   fi

   if [ $RESPONSE -eq 6 -o $RESPONSE -eq 7 ]; then
     FDEV="/dev/mtd0"
     FLASH_TYPE=`flash_info "$FDEV" |grep Type|cut -f2 -d ':' | cut -f2 -d' ' `
     # ERASE_SIZE=`flash_info "$FDEV" |grep Erase|cut -f2 -d ':' | cut -f2 -d' ' `

     case "$FLASH_TYPE" in
     NAND*)
     	break  # OK to proceed
        ;;
     *)
        echo "YAFFS rootfs is only available for platforms with NAND flash"
        continue
        ;;
      esac
   fi

   if [ $RESPONSE -eq 3 ]; then
       case `uname -m` in
          356*|7112|7312|7319|7328|7402|7454*)
              echo "HD install not applicable to diskless STBs"
              continue
              ;;

         *)
              break
              ;;
      esac
   fi

   # If we get here, we are OK to proceed
   break
done

#if [ $RESPONSE -eq 3 ]; then
#   stbcfgblk
#   exit 0
#fi
if [ $RESPONSE -eq 3 ]; then

echo "Preparing partition table..."
echo "********************************************************************"
echo "NOTE: When setting up the partition table, it is necessary to create"
echo "      the partitions and reboot the settop. After rebooting, the"
echo "      partitions become usable and the installation can proceed."
echo "********************************************************************"
echo ""
echo ""



HARDDRIVE="sda"
TMP_HARDDRIVE=""
#until [ -f /proc/ide/${TMP_HARDDRIVE}/geometry ] ; do

#echo "Please provide name of HD [${HARDDRIVE}]"
#echo ""

#read TMP_HARDDRIVE
#if [ "${TMP_HARDDRIVE}" != "" ]; then 
# HARDDRIVE=$TMP_HARDDRIVE
#else
# TMP_HARDDRIVE=${HARDDRIVE}
#fi 
#done

   echo "   Creating new partition table..."
   dd if=/dev/zero of=/dev/${HARDDRIVE} bs=1k count=40960 2> /dev/null

   # THT 6-09-04: Here we have to recalculate the HD geometry if running in 2.4.25 or later
   case "`uname -r`" in
   2.4.18*)
      cat /etc/partition.map | sfdisk -fq /dev/${HARDDRIVE}  2> /dev/null
      ;;
   2.4.25*)
      CHS=`cat /proc/ide/${HARDDRIVE}/geometry|grep logical|cut -f7 -d" "`
      #echo "C/H/S is $CHS"
      Cylinders=`echo $CHS|cut -d/ -f1`
      Heads=`echo $CHS|cut -d/ -f2`
      Sectors=`echo $CHS|cut -d/ -f3`
      echo "C/H/S is $Cylinders/$Heads/$Sectors"
      #TBD: Here we should make sure that the last partition is within $Cylinders
      if [ $Heads -eq 255 ]; then
	     cat /etc/partition-lba48.map | sfdisk -fq /dev/${HARDDRIVE}  2> /dev/null
      else
	     cat /etc/partition.map | sfdisk -fq /dev/${HARDDRIVE}  2> /dev/null
      fi
      ;;
   *)
      cat /etc/partition-lba48.map | sfdisk -fq /dev/${HARDDRIVE}  2> /dev/null
      ;;
   esac

   echo ""
   sleep 2

   echo ""
   echo "Formatting swap partition..."
   mkswap /dev/${HARDDRIVE}2 2> /dev/null

   echo ""
   echo "Enabling swap partition..."
   swapon /dev/${HARDDRIVE}2 2> /dev/null

   # Turn on VM overcommit (PR31081)
   echo 0 > /proc/sys/vm/overcommit_memory

   echo ""
   echo "Formatting ext3 file systems..."
   mke2fs -j /dev/${HARDDRIVE}1 2> /dev/null
   mke2fs -j /dev/${HARDDRIVE}3 2> /dev/null
   # Supressing periodic fsck
   tune2fs -i 0 /dev/${HARDDRIVE}1 2> /dev/null
   tune2fs -i 0 /dev/${HARDDRIVE}3 2> /dev/null

   case `uname -m` in
   356*|7112|7312|7319|7328)
    echo "HD install not applicable to diskless STBs"
    exit 1
    ;;
   7038*|7400*|7401*|97398|9745*)
    FS=ext2
	mke2fs /dev/${HARDDRIVE}4 -N 4096 -b 4096  2> /dev/null
	tune2fs -i 0 /dev/${HARDDRIVE}4 2> /dev/null
    ;;
   93730)
    FS=ext2
	mke2fs /dev/${HARDDRIVE}4 -N 4096  -b 4096  2> /dev/null
	tune2fs -i 0 /dev/${HARDDRIVE}4 2> /dev/null
    ;;
   7*)
    FS=ext3
   	mke2fs -j /dev/${HARDDRIVE}4 -N 4096  -b 4096 2> /dev/null
   	tune2fs -i 0 /dev/${HARDDRIVE}4 2> /dev/null
    ;;
   *)
    echo "Unknown platform"
    ;;
   esac

   echo ""
   echo "Mounting ${FS} root file systems on /dev/${HARDDRIVE}1 ..."
   if [ ! -d /mnt/hd ]; then
    mkdir /mnt/hd
   fi
   mount -t ${FS} /dev/${HARDDRIVE}1 /mnt/hd 2> /dev/null

echo ""

cd /
# Too bad  the --exclude flag which does not work on directories
tar -cf - `ls | grep -vE '\<mnt\>|\<tmp\>|\<proc\>|\<lost\+found\>|\<sys\>'` | (cd /mnt/hd; tar xvf -)
mkdir -p /mnt/hd/mnt/nfs
mkdir /mnt/hd/mnt/hd
mkdir /mnt/hd/proc
mkdir /mnt/hd/tmp
mkdir /mnt/hd/opt
mkdir /mnt/hd/data

# Adjust /etc/fstab to reflect how to mount /dev/hda4
mv /mnt/hd/etc/fstab /mnt/hd/etc/fstab.org
cat /mnt/hd/etc/fstab.org | sed 's/\/dev\/hda/\/dev\/'${HARDDRIVE}'/' > /mnt/hd/etc/fstab 
#if [ "$FS" == "ext2" ]; then
#   mv /mnt/hd/etc/fstab.ext2 /mnt/hd/etc/fstab
#   rm /mnt/hd/etc/fstab.*
#else
#   mv /mnt/hd/etc/fstab.ext3 /mnt/hd/etc/fstab
#   rm /mnt/hd/etc/fstab.*
#fi

# Edit init script to mount all HDs
rm /mnt/hd/etc/init.d/rcS
cp /var/tmp/rcS.hd /mnt/hd/etc/init.d/rcS
chmod +x /mnt/hd/etc/init.d/rcS

# jipeng - remove all dhcpcd related files here
rm /mnt/hd/etc/config/dhcpc/dhcpcd*

sleep 5
cd /
umount /mnt/hd

echo ""
echo "************************************************************"
echo "NOTE: After rebooting, edit the files '/etc/resolv.conf' and"
echo "      '/etc/init.d/rcS' to configure your network."
echo "************************************************************"
echo ""
echo "Platform hard drive successfully initialized. You may safely reboot."
echo ""
exit 0

fi
if [ $RESPONSE -eq 4 ]; then
   echo "Installing CRAMFS rootfs"
   echo ""
   IMAGE="cramfs-`uname -m`${DOCSIS}${ENDIAN}.img"
   FSTYPE="cramfs"
   ERASE_FLAG=
fi
if [ $RESPONSE -eq 5 ]; then
   echo "Installing SQUASHFS rootfs"
   echo ""
   IMAGE="squashfs-`uname -m`${DOCSIS}${ENDIAN}.img"
   FSTYPE="squashfs"
   ERASE_FLAG=
fi
if [ $RESPONSE -eq 6 -o $RESPONSE -eq 7 ]; then
   echo "Installing YAFFS rootfs"
   echo ""
   # Currently mkyaffs does not handle BE, so we just copy the FS over on the fly
   #IMAGE="yaffs2-`uname -m`${DOCSIS}${ENDIAN}.img"
   FSTYPE="yaffs2"
   ERASE_FLAG=
fi

if [ $RESPONSE -eq 1 -o $RESPONSE -eq 2 ]; then
   echo "Installing JFFS2 rootfs"
   echo ""
   ERASE_FLAG='-j'
fi
if [ $RESPONSE -eq 8 ]; then
   echo ""
   exit 0
fi
if [ $RESPONSE -eq 1 -o $RESPONSE -eq 2 -o $RESPONSE -eq 4  -o $RESPONSE -eq 5 \
       -o $RESPONSE -eq 6 -o $RESPONSE -eq 7 ]; then
   case "`uname -m`" in
   7315bbx)
      echo "The STB BCM97315-BBX does not support a root file system partition"
      echo "on flash.  Operation aborted"
      exit 1
      ;;

   7115)
     FDEV="/dev/mtd1"
     MTD_DEV="/dev/mtdblock1"
     ;;

   93730)
     FDEV="/dev/mtd1"
     MTD_DEV="/dev/mtdblock1"
     ;;

  356*|7*|97*)
     FDEV="/dev/mtd0"
     MTD_DEV="/dev/mtdblock0"

     ;;
esac


   case "`uname -m`" in
   93730|356*|7*|97*)

     echo ""

     # THT: Do ping test only if we need to TFTP (Options 1, 2, 4 & 5)
     if [ $RESPONSE -eq 1 -o  $RESPONSE -eq 2 -o $RESPONSE -eq 4 -o  $RESPONSE -eq 5 ]; then
        echo "ping -c 4 $TFTP_SERVER"
        ping -c 4 $TFTP_SERVER > ping.err 2>&1
        grep "bytes from" ping.err > /dev/null 2>&1
        if [ "$?" -eq 0 ]; then
           echo "ping: succeed"
           rm ping.err
        else
           cat ping.err;rm ping.err
           exit 1
        fi
     fi

     FDIR=${CUR_REL}

     FLASH_TYPE=`flash_info "$FDEV" |grep Type|cut -f2 -d ':' | cut -f2 -d' ' `
     ERASE_SIZE=`flash_info "$FDEV" |grep Erase|cut -f2 -d ':' | cut -f2 -d' ' `


     case "$FLASH_TYPE" in
     NOR*)
     	# Do not use the -j flag with summary on NOR flash
     	ERASE_FLAG=
	if [ `uname -m` == "7401c0" -o `uname -m` == "7401c0_be" ];
	then
		if [ $RESPONSE -eq 1 -o $RESPONSE -eq 2 ]; 
		then
			if [ ${ERASE_SIZE} -eq 64 ]; 
			then
				IMAGE="jffs2-${ERASE_SIZE}k-`uname -m`${DOCSIS}${ENDIAN}.img"
			fi
		fi
	fi
     	;;
     esac

     echo "Erasing $FLASH_TYPE flash with $ERASE_SIZE kB erase sectors on $FDEV..."
     eraseall $ERASE_FLAG "$FDEV"

     test -d /mnt/flash || mkdir -p /mnt/flash

     # THT 011207: Change to allow support for both NOR and NAND flash co-existing on a board
     # using the same kernel, depending on the chip select
     case "$FLASH_TYPE" in
     NAND*)
     	case "$RESPONSE" in
	1|2)  # JFFS2
    		IMAGE="jffs2-${ERASE_SIZE}k-`uname -m`${DOCSIS}${ENDIAN}-nand.img"

     		echo "Fetching flash image ${IMAGE} from ${TFTP_SERVER}:${IMGPFX}${IMAGE}"
     		tftp -gr ${IMGPFX}${IMAGE} -l /tmp/${IMAGE} ${TFTP_SERVER} &> tftp.err
		if [ -e /tmp/$IMAGE ]; then
			echo "Writing flash image..."
        		nandwrite -p ${FDEV} /tmp/${IMAGE}
		else
			echo "Cannot fetch flash image ${IMGPFX}${IMAGE} from ${TFTP_SERVER}"
			exit 2
		fi
		;;

	4|5)  # CRAMFS and SQUASHFS
		case "$RESPONSE" in
		4)
			IMAGE="cramfs-`uname -m`${DOCSIS}${ENDIAN}-nand.img"
			;;
		5)
			IMAGE="squashfs-`uname -m`${DOCSIS}${ENDIAN}-nand.img"
			;;
		esac
  		echo "Fetching flash image ${IMAGE} from ${TFTP_SERVER}:${IMGPFX}${IMAGE}"
     		tftp -gr ${IMGPFX}${IMAGE} -l /tmp/${IMAGE} ${TFTP_SERVER} &> tftp.err
		if [ -e /tmp/$IMAGE ]; then
			echo "Writing flash image..."
        		nandwrite ${FDEV} /tmp/${IMAGE}
		else
			echo "Cannot fetch flash image ${IMGPFX}${IMAGE} from ${TFTP_SERVER}"
			exit 2
		fi
		# For NAND flash, we can't mount /dev/romblock so quit now
		echo "Copied rootfs to flash complete.  You may now safely reboot"
      		exit 0
		;;

	6|7)  # YAFFS2
		# sidc - PR33102 Since we derive a yaffs2 image from cramfs fs image we do not
		# need to check the erase size. 
		# Source: cramfs image mounted in loopback Dest: yaffs image to be created
		IMAGE="yaffs-frm-cramfs-`uname -m`${DOCSIS}${ENDIAN}-nand.img"
		mount -t ${FSTYPE} "$MTD_DEV" /mnt/flash
     		echo "Fetching flash image ${IMAGE} from ${TFTP_SERVER}:${IMGPFX}${IMAGE}"
     		tftp -gr ${IMGPFX}${IMAGE} -l /tmp/${IMAGE} ${TFTP_SERVER} &> tftp.err
		if [ -e /tmp/$IMAGE ]; then
			mkdir -p /mnt/yaffs_src
			mount -t cramfs -o loopback /tmp/${IMAGE} /mnt/yaffs_src
			cd /mnt/yaffs_src
			echo "Creating files for yaffs2 image..."
			#tar -cf - `ls` | (cd /mnt/flash; tar xvf -) 2>&1 > /dev/null
			cp -dpR . /mnt/flash
		else
			echo "Cannot fetch flash image ${IMGPFX}${IMAGE} from ${TFTP_SERVER}"
			exit 2
		fi
		cd /
		umount /mnt/yaffs_src
		rm -rf /mnt/yaffs_src
		;;

	esac
     ;;

     NOR*) # NOR flashes
    	echo "Fetching flash image ${IMAGE} from ${TFTP_SERVER}:${IMGPFX}${IMAGE}"
    	tftp -gr ${IMGPFX}${IMAGE} -l /tmp/$IMAGE ${TFTP_SERVER} &> tftp.err
        if [ -e /tmp/$IMAGE ]; then
		echo "Writing flash image..."
		cat /tmp/$IMAGE > $FDEV
		# With Summary enabled, append the JFFS2 image with 
		# cleanmarkers for faster umount time
		if [ $RESPONSE -eq 1 -o $RESPONSE -eq 2 ]; then
			imgsize=`ls -l /tmp/$IMAGE | awk '{print $5}'`
			/bin/norcleanmark $FDEV $imgsize
		fi
	else
		echo "Cannot fetch flash image ${IMGPFX}${IMAGE} from ${TFTP_SERVER}"
		exit 2
	fi
     ;;
     esac
     
     if [ $RESPONSE -ne 6 -a  $RESPONSE -ne 7  ]; then
     if [ `wc -l < tftp.err` -eq "0" ]; then
        rm tftp.err
     else
           echo "tftp: failed to get ${TFTP_SERVER}:${IMGPFX}${IMAGE}"
        cat tftp.err;rm tftp.err
        exit 3
     fi
     fi

     sleep 2

     if [ $RESPONSE -eq 1 -o  $RESPONSE -eq 2 ]; then
     	echo "Mounting root file system $FSTYPE as $MTD_DEV..."
     	mount -t $FSTYPE "$MTD_DEV" /mnt/flash
     fi
     ;;

   *)
      echo "Unrecognized platform"
      exit 2
      ;;

   esac

   # if Option 2,4,5,7 are selected (Copy rootfs only) we are done
   # Option 4 (CRAMFS) and 5 (SQUASHFS) already have tmpfs handled during FS image creation on host side.
   if [ $RESPONSE -eq 2 -o $RESPONSE -eq 4 -o $RESPONSE -eq 5 -o $RESPONSE -eq 7 ]; then
      [ $RESPONSE -eq 2 -o $RESPONSE -eq 7 ] && umount /mnt/flash
      echo "Copied rootfs to flash complete.  You may now safely reboot"
      exit 0
   fi

   echo "Set up to mount /var and /etc RW"
   cd /mnt/flash/var
   rm -rf /mnt/flash/tmp
   ln -s /var/tmp /mnt/flash/tmp

   # Creating tmpfs images
   dd if=/dev/zero of=/mnt/flash/tmpfsvar.img bs=1024 count=500
   dd if=/dev/zero of=/mnt/flash/tmpfsetc.img bs=1024 count=256
   #
   # Create tarball for var
   #
   cd /mnt/flash/var
   # Create script to mount var RW
   cp /mnt/flash/var/tmp/mountvar.sh /mnt/flash/etc
   chmod +x /mnt/flash/etc/mountvar.sh
   # Substitute with new rc.sysinit script
   cp /mnt/flash/var/tmp/rcS /mnt/flash/etc/init.d/rcS
   rm /mnt/flash/var/tmp/*
   tar -cvf /mnt/flash/var.img . 2>&1 >/dev/null

   #
   # Create tarball for etc
   #
   cd /mnt/flash/etc
   tar -cvf /mnt/flash/etc.img . 2>&1 >/dev/null

   # Clean up
   cd /
   rm -rf /mnt/flash/var/*
   echo ""
   echo "Syncing flash file system..."
   sync; sync
   echo "Unmounting flash file system..."
   echo ""
   umount /mnt/flash
   echo ""

   echo ""
   echo "Finished..."
   exit 0
fi

